[
	// Find + Replace
	//{ "keys": ["super+alt+f"],      "command": "show_panel", "args": {"panel": "find",    "reverse": false} },
	//{ "keys": ["super+f"],          "command": "show_panel", "args": {"panel": "replace", "reverse": false} },
	{ "keys": ["super+ctrl+g"],     "command": "replace_next"                               },
	{ "keys": ["super+alt+ctrl+g"], "command": "replace_all", "args": {"close_panel": true} },
	{ "keys": ["super+g"],          "command": "find_next" },
	{ "keys": ["super+shift+g"],    "command": "find_prev" },
	{ "keys": ["super+e"],          "command": "slurp_find_string"    },
	{ "keys": ["super+alt+e"],      "command": "slurp_replace_string" },

	// Edit Project (uses former “slurp_replace_string” keybinding)
	{ "keys": ["super+shift+e"], "command": "open_file", "args": {"file": "${project}"} },


	// REMAP: Set Mark (prev: `super+k, super+space`)
	{ "keys": ["super+k", "super+s"], "command": "set_mark" },

	// REMAP: Swtich File (prev: `super+alt+up`)
	{ "keys": ["super+alt+shift+tab"], "command": "switch_file", "args": {"extensions": ["cpp", "cxx", "cc", "c", "hpp", "hxx", "hh", "h", "ipp", "inl", "m", "mm"]} },

	// REMAP: Goto Reference (prev: `super+alt+shift+down`)
	{ "keys": ["super+alt+up"], "command": "goto_reference" },


	// Wrap in Tag
	{ "keys": ["super+shift+,"], "command": "insert_snippet", "args": { "name": "Packages/XML/Snippets/long-tag.sublime-snippet" }, "context":
		[
			{ "key": "selector",                   "operator": "equal",              "operand": "text.html, text.xml",    "match_all": true },
		]
	},
	// Wrap in Selector
	{ "keys": ["super+shift+,"], "command": "insert_snippet", "args": { "name": "Packages/User/Snippets/CSS/wrap-in-selector.sublime-snippet" }, "context":
		[
			{ "key": "selector",                   "operator": "equal",              "operand": "source.css, source.less, source.sass, source.scss",               "match_all": true },
		]
	},


	// Re-indent Lines
	{ "keys": ["super+alt+tab"], "command": "reindent", "args": { "single_line": true } },

	// Split Selection
	{ "keys": ["super+alt+l"], "command": "split_selection_into_lines" },

	// Goto Line
	{ "keys": ["super+shift+l"], "command": "show_overlay", "args": {"overlay": "goto", "text": ":"} },


	// Replace with Spaces
	{ "keys": ["ctrl+shift+space"], "command": "insert_snippet", "args": {"contents": "${SELECTION/./ /g}"} },


	// Git Gutter
	{ "keys": ["ctrl+g"],       "command": "git_gutter_next_change" },
	{ "keys": ["ctrl+shift+g"], "command": "git_gutter_prev_change" },


	// Alignment
	{ "keys": ["super+alt+shift+a"], "command": "alignment" },

	{ "keys": ["super+ctrl+shift+left"],  "command": "move_text_left"  },
	{ "keys": ["super+ctrl+shift+right"], "command": "move_text_right" },
	{ "keys": ["super+ctrl+shift+up"],    "command": "move_text_up"    },
	{ "keys": ["super+ctrl+shift+down"],  "command": "move_text_down"  },


	// ImportJS
	{ "keys": ["super+alt+i"],          "command": "import_js", "args": { "command": "fix"  } },
	// (Override switch-file.)
	{ "keys": ["super+alt+shift+up"],   "command": "import_js", "args": { "command": "word" } },
	{ "keys": ["super+alt+shift+down"], "command": "import_js", "args": { "command": "goto" } },


	// JSDoc
	{ "keys": ["super+j"], "command": "jsdocs_join", "context":
		[
			{ "key": "selector",        "operator": "equal", "operand": "comment.block" },
		]
	},
	{ "keys": ["super+j"], "command": "jsdocs_join", "context":
		[
			{ "key": "selector",        "operator": "equal", "operand": "comment.line" },
		]
	},
	{ "keys": ["super+alt+q"], "command": "jsdocs_wrap_lines", "context":
		[
			{ "key": "selector",        "operator": "equal", "operand": "comment.block", "match_all": true },
		]
	},
	{ "keys": ["super+alt+["], "command": "jsdocs_fold", "context":
		[
			{ "key": "selector",        "operator": "equal", "operand": "comment.block", "match_all": true },
			{ "key": "selection_empty", "operator": "equal", "operand": true,            "match_all": true },
		]
	},
	// add line after, in a DocBlock
	{ "keys": ["super+enter"], "command": "run_macro_file", "args": {"file": "Packages/DocBlockr/Add DocBlockr Line.sublime-macro"}, "context":
		[
			{ "key": "setting.auto_indent",   "operator": "equal",          "operand": true,            "match_all": true },
			{ "key": "selector",              "operator": "equal",          "operand": "comment.block", "match_all": true },
			{ "key": "auto_complete_visible", "operator": "equal",          "operand": false,           "match_all": true },
			{ "key": "preceding_text",        "operator": "regex_contains", "operand": "^\\s*\\*",      "match_all": true }
		]
	},
	// add line before, in a DocBlock
	{ "keys": ["super+shift+enter"], "command": "run_macro_file", "args": {"file": "Packages/DocBlockr/Add DocBlockr Line Before.sublime-macro"}, "context":
		[
			{ "key": "setting.auto_indent",   "operator": "equal",          "operand": true,            "match_all": true },
			{ "key": "selector",              "operator": "equal",          "operand": "comment.block", "match_all": true },
			{ "key": "auto_complete_visible", "operator": "equal",          "operand": false,           "match_all": true },
			{ "key": "preceding_text",        "operator": "regex_contains", "operand": "^\\s*\\*",      "match_all": true }
		]
	},



	//
	// Macros
	//

	// Wrap-to-EOL in parentheses.
	{ "keys": ["super+shift+9"], "command": "run_macro_file", "args": {"file": "res://Packages/User/Macros/Wrap to EOL in Parens.sublime-macro"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal", "operand": true                    },
			{ "key": "selection_empty",            "operator": "equal", "operand": true, "match_all": true },
		]
	},

	// Add semicolon at EOL.
	{ "keys": ["super+shift+;"], "command": "run_macro_file", "args": {"file": "res://Packages/User/Macros/Add Semicolon at EOL.sublime-macro"}, "context":
		[
			{ "key": "selection_empty",            "operator": "equal", "operand": true, "match_all": true },
		]
	},

	// Add close parenthesis at EOL.
	{ "keys": ["super+shift+0"], "command": "run_macro_file", "args": {"file": "res://Packages/User/Macros/Add Paren at EOL.sublime-macro"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal", "operand": true                    },
			{ "key": "selection_empty",            "operator": "equal", "operand": true, "match_all": true },
		]
	},

	// Delete matching bracket (from start).
	{ "keys": ["super+alt+backspace"], "command": "run_macro_file", "args": {"file": "res://Packages/User/Macros/Delete Matching Bracket (Left).sublime-macro"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true },
			{ "key": "preceding_text",             "operator": "regex_contains",     "operand": "[{([]$",                  "match_all": true },
		]
	},
	// Delete matching bracket (from end).
	{ "keys": ["super+alt+backspace"], "command": "run_macro_file", "args": {"file": "res://Packages/User/Macros/Delete Matching Bracket (Right).sublime-macro"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true },
			{ "key": "preceding_text",             "operator": "regex_contains",     "operand": "[})\\]]$",                "match_all": true },
		]
	},

	// Wrap with Spaces
	{ "keys": [" "], "command": "run_macro_file", "args": {"file": "res://Packages/User/Macros/Wrap with Spaces.sublime-macro"},
		"context": [
			{ "key": "setting.auto_match_enabled", "operator": "equal",          "operand": true },
			{ "key": "selection_empty",            "operator": "equal",          "operand": false,                     "match_all": true },
			{ "key": "selector",                   "operator": "equal",          "operand": "meta.group.braces.curly", "match_all": true },
			{ "key": "auto_complete_visible",      "operator": "equal",          "operand": false,                     "match_all": true },
			//{ "key": "preceding_text",             "operator": "regex_contains", "operand": "{$",                      "match_all": true },
			//{ "key": "following_text",             "operator": "regex_contains", "operand": "^}",                      "match_all": true },
		]
	},



	// Insert interpolated code brackets in JS template strings.
	{ "keys": ["$"], "command": "insert_snippet", "args": {"contents": "\\${$0}"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true,                     "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "string.template-string - entity, string.template-string entity punctuation.template-string.element.begin", "match_all": true },
			{ "key": "following_text",             "operator": "not_regex_contains", "operand": "^{",                     "match_all": true },
			//{ "key": "following_text",             "operator": "regex_contains",     "operand": "^(?:\t| |\\)|]|\\}|$)",  "match_all": true },
			//{ "key": "preceding_text",             "operator": "not_regex_contains", "operand": "[`a-zA-Z0-9_]$",         "match_all": true },
		]
	},
	// Wrap JS template string selection in interpolated code brackets.
	{ "keys": ["$"], "command": "insert_snippet", "args": {"contents": "\\${${0:$SELECTION}}"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": false,                    "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "string.template-string", "match_all": true },
		]
	},



	// Insert variables in Sublime strings.
	{ "keys": ["$"], "command": "insert_snippet", "args": {"contents": "\\${${1:0}:${2:label}}"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true,                     "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "string source.sublime",  "match_all": true },
			{ "key": "following_text",             "operator": "not_regex_contains", "operand": "^{",                     "match_all": true },
			//{ "key": "following_text",             "operator": "regex_contains",     "operand": "^(?:\t| |\\)|]|\\}|$)",  "match_all": true },
			//{ "key": "preceding_text",             "operator": "not_regex_contains", "operand": "[`a-zA-Z0-9_]$",         "match_all": true },
		]
	},
	{ "keys": ["$"], "command": "insert_snippet", "args": {"contents": "\\${${1:0}:${2:$SELECTION}}"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": false,                    "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "string source.sublime",  "match_all": true },
		]
	},



	//
	// Handlebars Key-Triggered Snippets
	//
	{ "keys": [" "], "command": "insert_snippet", "args": {"contents": " |$0|"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",          "operand": true },
			{ "key": "selection_empty",            "operator": "equal",          "operand": true,               "match_all": true },
			{ "key": "preceding_text",             "operator": "regex_contains", "operand": "\\sas$",           "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains", "operand": "^\\s*(?!\\s|\\|)", "match_all": true },
			{ "key": "selector",                   "operator": "equal",          "operand": "text.html.handlebars meta.tag - comment", "match_all": true },
		]
	},
	// Insert additional braces and auto-pair (when editing Handlebars).
	// OVERRIDE: Auto-pair braces.
	{ "keys": ["{"], "command": "insert_snippet", "args": {"contents": "{{$0}}"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",          "operand": true },
			{ "key": "selection_empty",            "operator": "equal",          "operand": true,                      "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains", "operand": "^(?:\t| |\\)|]|\\}|>|$)", "match_all": true },
			{ "key": "selector",                   "operator": "equal",          "operand": "text.html.handlebars - meta.tag.template - comment", "match_all": true },
		]
	},
	// Wrap block in double-braces (when editing Handlebars).
	// OVERRIDE: Wrap block in braces.
	//{ "keys": ["{"], "command": "wrap_block", "args": {"begin": "{{", "end": "}}"}, "context":
	{ "keys": ["{"], "command": "insert_snippet", "args": {"contents": "{{$0}}"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",       "operand": true },
			{ "key": "indented_block",                                                         "match_all": true },
			{ "key": "selection_empty",            "operator": "equal",       "operand": true, "match_all": true },
			{ "key": "following_text",             "operator": "regex_match", "operand": "^$", "match_all": true },
			{ "key": "selector",                   "operator": "equal",       "operand": "text.html.handlebars - meta.tag.template - comment", "match_all": true },
		]
	},
	{ "keys": ["{"], "command": "insert_snippet", "args": {"contents": "{{${0:$SELECTION}}}"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal", "operand": true },
			{ "key": "selection_empty",            "operator": "equal", "operand": false, "match_all": true },
			{ "key": "selector",                   "operator": "equal", "operand": "text.html.handlebars - meta.tag.template - comment", "match_all": true },
		]
	},
	{ "keys": ["}"], "command": "move", "args": {"by": "subword_ends", "forward": true}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",          "operand": true },
			{ "key": "selection_empty",            "operator": "equal",          "operand": true,      "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains", "operand": "^\\}\\}", "match_all": true },
			{ "key": "selector",                   "operator": "equal",          "operand": "text.html.handlebars - meta.tag.template - comment", "match_all": true },
		]
	},
	{ "keys": ["backspace"], "command": "run_macro_file", "args": {"file": "res://Packages/User/Macros/Delete Left Right Twice.sublime-macro"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",          "operand": true },
			{ "key": "selection_empty",            "operator": "equal",          "operand": true,      "match_all": true },
			{ "key": "preceding_text",             "operator": "regex_contains", "operand": "\\{\\{$", "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains", "operand": "^\\}\\}", "match_all": true },
			{ "key": "selector",                   "operator": "equal",          "operand": "text.html.handlebars - meta.tag.template.unescaped - comment", "match_all": true },
		]
	},



	// Auto-pair asterisk/underscore/tilde in doc comments.
	{ "keys": ["*"], "command": "insert_snippet", "args": {"contents": "*$0*"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true,                       "match_all": true },
			{ "key": "preceding_text",             "operator": "regex_contains",     "operand": "(^\\*{0,2}|\\s\\*{0,2})$", "match_all": true },
			{ "key": "preceding_text",             "operator": "not_regex_contains", "operand": "(^|\\s)/\\*+$",            "match_all": true },
			{ "key": "following_text",             "operator": "not_regex_contains", "operand": "^[a-zA-Z0-9]|\\*/",        "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "comment",                  "match_all": true },
			{ "key": "selector",                   "operator": "not_equal",          "operand": "comment.markdown.code, comment.markdown.strong-emphasis, comment.block.js", "match_all": true },
		]
	},
	{ "keys": ["*"], "command": "insert_snippet", "args": {"contents": "*${0:$SELECTION}*"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": false,                      "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "comment",                  "match_all": true },
			{ "key": "selector",                   "operator": "not_equal",          "operand": "comment.markdown.code, comment.markdown.strong-emphasis comment.block.js", "match_all": true },
		]
	},
	{ "keys": ["*"], "command": "move",           "args": {"by": "characters", "forward": true}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true,                       "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains",     "operand": "^\\*{1,3}(\\s|$)",         "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "comment.markdown.emphasis, comment.markdown.strong, comment.markdown.strong-emphasis", "match_all": true },
		]
	},
	{ "keys": ["_"], "command": "insert_snippet", "args": {"contents": "_${0}_"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true,                   "match_all": true },
			{ "key": "preceding_text",             "operator": "regex_contains",     "operand": "(^_{0,2}|\\s_{0,2})$", "match_all": true },
			{ "key": "following_text",             "operator": "not_regex_contains", "operand": "^[a-zA-Z0-9]",         "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "comment",              "match_all": true },
			{ "key": "selector",                   "operator": "not_equal",          "operand": "comment.markdown.code, comment.markdown.strong-emphasis", "match_all": true },
		]
	},
	{ "keys": ["_"], "command": "insert_snippet", "args": {"contents": "_${0:$SELECTION}_"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": false,                  "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "comment",              "match_all": true },
			{ "key": "selector",                   "operator": "not_equal",          "operand": "comment.markdown.code, comment.markdown.strong-emphasis", "match_all": true },
		]
	},
	{ "keys": ["_"], "command": "move",           "args": {"by": "characters", "forward": true}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true,                   "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains",     "operand": "^_{1,3}(\\s|$)",       "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "comment.markdown.emphasis, comment.markdown.strong, comment.markdown.strong-emphasis", "match_all": true },
		]
	},
	{ "keys": ["~"], "command": "insert_snippet", "args": {"contents": "~$0~"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true,           "match_all": true },
			{ "key": "preceding_text",             "operator": "regex_contains",     "operand": "(^|\\s|~)$",   "match_all": true },
			{ "key": "following_text",             "operator": "not_regex_contains", "operand": "^[a-zA-Z0-9]", "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "comment",      "match_all": true },
			{ "key": "selector",                   "operator": "not_equal",          "operand": "comment.markdown.code, comment.markdown.strike", "match_all": true },
		]
	},
	{ "keys": ["~"], "command": "insert_snippet", "args": {"contents": "~${0:$SELECTION}~"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": false,          "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "comment",      "match_all": true },
			{ "key": "selector",                   "operator": "not_equal",          "operand": "comment.markdown.code, comment.markdown.strike", "match_all": true },
		]
	},
	{ "keys": ["~"], "command": "move",           "args": {"by": "characters", "forward": true}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true,           "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains",     "operand": "^~(\\s|$)",    "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "comment.markdown.strike", "match_all": true },
		]
	},
	{ "keys": ["backspace"], "command": "run_macro_file", "args": {"file": "res://Packages/Default/Delete Left Right.sublime-macro"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",          "operand": true },
			{ "key": "selection_empty",            "operator": "equal",          "operand": true,                      "match_all": true },
			{ "key": "preceding_text",             "operator": "regex_contains", "operand": "[*_~]$",                  "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains", "operand": "^[*_~]+(?![a-zA-Z0-9])",  "match_all": true },
			{ "key": "selector",                   "operator": "equal",          "operand": "comment",                 "match_all": true },
			{ "key": "selector",                   "operator": "not_equal",      "operand": "comment.markdown, punctuation.definition.markdown.strong-emphasis.begin, punctuation.definition.markdown.strong.begin, punctuation.definition.markdown.emphasis.begin, punctuation.definition.markdown.strike.begin", "match_all": true },
		]
	},
	// Remove paired asterisk if a space is typed next.
	{ "keys": [" "], "command": "run_macro_file", "args": {"file": "res://Packages/User/Macros/Space Delete Right.sublime-macro"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true,           "match_all": true },
			{ "key": "preceding_text",             "operator": "regex_contains",     "operand": "(^|\\s)\\*$",  "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains",     "operand": "^\\*+(\\s|$)", "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "comment",      "match_all": true },
		]
	},
	// Remove paired asterisk if a slash is typed next.
	{ "keys": ["/"], "command": "run_macro_file", "args": {"file": "res://Packages/User/Macros/Slash Delete Right.sublime-macro"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true,            "match_all": true },
			{ "key": "preceding_text",             "operator": "regex_contains",     "operand": "\\*$",          "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains",     "operand": "^\\*",          "match_all": true },
			{ "key": "selector",                   "operator": "equal",              "operand": "comment.block", "match_all": true },
		]
	},



	// Auto-pair backticks.
	{ "keys": ["`"], "command": "insert_snippet", "args": {"contents": "`$0`"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",              "operand": true },
			{ "key": "selection_empty",            "operator": "equal",              "operand": true,                      "match_all": true },
			{ "key": "preceding_text",             "operator": "not_regex_contains", "operand": "[`a-zA-Z0-9_]$",          "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains",     "operand": "^(?:\t| |\\)|]|\\}|$)",   "match_all": true },
			{ "key": "selector",                   "operator": "not_equal",          "operand": "string.template-string",  "match_all": true },
			{ "key": "eol_selector",               "operator": "not_equal",          "operand": "string.template-string",  "match_all": true },
		]
	},
	{ "keys": ["`"], "command": "insert_snippet", "args": {"contents": "`${0:$SELECTION}`"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal", "operand": true },
			{ "key": "selection_empty",            "operator": "equal", "operand": false, "match_all": true },
		]
	},
	{ "keys": ["`"], "command": "move", "args": {"by": "characters", "forward": true}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",          "operand": true },
			{ "key": "selection_empty",            "operator": "equal",          "operand": true,                                                                  "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains", "operand": "^`",                                                                  "match_all": true },
			{ "key": "selector",                   "operator": "not_equal",      "operand": "punctuation.definition.template-string.begin",                        "match_all": true },
			{ "key": "eol_selector",               "operator": "not_equal",      "operand": "string.template-string - punctuation.definition.template-string.end", "match_all": true },
		]
	},
	// { "keys": ["`"], "command": "run_macro_file", "args": {"file": "Packages/MarkdownEditing/macros/Skip Closing Character.sublime-macro"}, "context":
	// 	[
	// 		{ "key": "selection_empty", "operator": "equal",          "operand": true,                 "match_all": true },
	// 		{ "key": "following_text",  "operator": "regex_contains", "operand": "^`",                 "match_all": true },
	// 		//{ "key": "selector",        "operator": "equal",          "operand": "text.html.markdown", "match_all": true }
	// 	]
	// },
	{ "keys": ["backspace"], "command": "run_macro_file", "args": {"file": "res://Packages/Default/Delete Left Right.sublime-macro"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",          "operand": true },
			{ "key": "selection_empty",            "operator": "equal",          "operand": true,                                                                  "match_all": true },
			{ "key": "preceding_text",             "operator": "regex_contains", "operand": "`$",                                                                  "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains", "operand": "^`",                                                                  "match_all": true },
			{ "key": "selector",                   "operator": "not_equal",      "operand": "punctuation.definition.template-string.begin",                        "match_all": true },
			{ "key": "eol_selector",               "operator": "not_equal",      "operand": "string.template-string - punctuation.definition.template-string.end", "match_all": true },
		]
	},



	// Auto-pair parenthesis in Sublime Color Schemes.
	{ "keys": ["("], "command": "insert_snippet", "args": {"contents": "($0)"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",          "operand": true },
			{ "key": "selection_empty",            "operator": "equal",          "operand": true,                      "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains", "operand": "^(?:\t| |\\)|]|;|\\}|$)", "match_all": true },
		]
	},



	{ "keys": ["\""], "command": "insert_snippet", "args": {"contents": "\"$1\"$2: \"$3\","}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",          "operand": true },
			{ "key": "selection_empty",            "operator": "equal",          "operand": true,                                                                       "match_all": true },
			{ "key": "preceding_text",             "operator": "regex_contains", "operand": "^\\s*$",                                                                   "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains", "operand": "^\\s*$",                                                                   "match_all": true },
			{ "key": "selector",                   "operator": "equal",          "operand": "source.json.sublime  meta.mapping.value.json  meta.mapping.json - string", "match_all": true },
		]
	},
	{ "keys": ["v"], "command": "insert_snippet", "args": {"contents": "var($1)$0"}, "context":
		[
			{ "key": "setting.auto_match_enabled", "operator": "equal",          "operand": true },
			{ "key": "selection_empty",            "operator": "equal",          "operand": true,                                                                       "match_all": true },
			{ "key": "preceding_text",             "operator": "regex_contains", "operand": "[^a-zA-Z0-9]$",                                                            "match_all": true },
			{ "key": "following_text",             "operator": "regex_contains", "operand": "^[^a-zA-Z0-9]",                                                            "match_all": true },
			{ "key": "selector",                   "operator": "equal",          "operand": "source.json.sublime.color-scheme  meta.mapping.value.json  string.quoted.double.json  meta.color.sublime-color-scheme - meta.function-call.var", "match_all": true },
		]
	},
]
